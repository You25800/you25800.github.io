import{_ as p,c as t,o as e,b3 as i}from"./chunks/framework.CatkIGlB.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"其他/元数据多组户整体架构设计.md","filePath":"其他/元数据多组户整体架构设计.md","lastUpdated":1710384876000}'),l={name:"其他/元数据多组户整体架构设计.md"};function r(d,a,o,h,n,s){return e(),t("div",null,[...a[0]||(a[0]=[i('<h2 id="需求" tabindex="-1">需求 <a class="header-anchor" href="#需求" aria-label="Permalink to &quot;需求&quot;">​</a></h2><ol><li><p>同一个领域模型下，不同组户字段不一样多，同一个字段名语义也可能不一样</p><p>比如商品表，租户A有20个字段，租户B有15个字段，怎么存储？表结构怎么建？</p><p>比如都叫weight，租户A的语义可能是重量，租户B的语义可能是权重。</p></li><li><p>不同租户看到的菜单不一样，同一个租户下面的用记看到的菜单也可能不一样，怎么实现？</p></li><li><p>不同租户的路由不一样，同一个租户下面不同的用户看到的菜单也可能不一样，怎么实现？</p></li><li><p>同一个字段不同租户要求的样式不一样，同一个字段的行为也可能不一样。</p></li><li><p>同一个字段，在不同的平台的样式可能不一样，在Android，ios，web的样式不一样。</p></li><li><p>不同租户存储在不同的库中，租户可以指定自己的库，自己的表，怎么实现？</p></li><li><p>同时支持多种数据集成，比如数据库集成，API集成，消息集成等，比如API集成，怎么做成通用的？</p></li><li><p>不同租户对同一个字段有不同的计算逻辑，验证逻辑，怎么实现？</p></li><li><p>上下游字段做映射，比如上游A字段和本地B字段，做了映射，后来又改成了上游A和本地C字段做映射脏数据的问题，如何清洗？</p></li><li><p>如何打包部属，客户端如何打包部属，web端如何打包部属。</p></li></ol><h2 id="ddd建模" tabindex="-1">DDD建模 <a class="header-anchor" href="#ddd建模" aria-label="Permalink to &quot;DDD建模&quot;">​</a></h2><p>建立领域模型，比如用户表，菜单表，路由表，订单表，风险表，异常表。</p><p>这些都是领域模型，对该领域模型中的通用字段，常用字段进行抽取，建立一张行存储的表。对不同租户可能存在的差异字段，建立一张列存储的表。</p><h2 id="东西向元数据" tabindex="-1">东西向元数据 <a class="header-anchor" href="#东西向元数据" aria-label="Permalink to &quot;东西向元数据&quot;">​</a></h2><p>东西向主要是应用侧，应用和应用之间互调</p><p>上游中游下游系统之间的对接</p><p>比如数据池，多个上游系统接入，然后推送到多个不同下游系统</p><p>比如收单系统，多个租户接入，对接多个下游不同系统</p><h2 id="南北向元数据" tabindex="-1">南北向元数据 <a class="header-anchor" href="#南北向元数据" aria-label="Permalink to &quot;南北向元数据&quot;">​</a></h2><p>南北向主要是用户侧</p><p>租户，领域，用户，路由，菜单，商品，订单，评论，这些领域模型，跟用户相关的</p><p>比如：不同的租户，需要的菜单和路由可能不同，商品属性可以不同</p><h2 id="行存储-列存储" tabindex="-1">行存储+列存储 <a class="header-anchor" href="#行存储-列存储" aria-label="Permalink to &quot;行存储+列存储&quot;">​</a></h2><p>比如用户表，有下面字段name,nickname,password,sex,imname,impassword,imavator等</p><p>建行表：t_user_base,有如下字段：name,nickname,password,sex</p><p>再建一个列表t_user_extend，把不常用的，或者后可能会出现的字段，建立列存储imname,</p><p>​ impassword,</p><p>​ imavator</p><p>​ ......</p><h2 id="多数据源" tabindex="-1">多数据源 <a class="header-anchor" href="#多数据源" aria-label="Permalink to &quot;多数据源&quot;">​</a></h2><p>这都是现实存在的问题</p><p>不同的租户可能使用不同的数据源</p><p>同一个租户分库分表的情况下也需要定义多个数据源</p><p>同一个租户不同的领域模型也可能需要不同的数据源</p><h2 id="分库分表" tabindex="-1">分库分表 <a class="header-anchor" href="#分库分表" aria-label="Permalink to &quot;分库分表&quot;">​</a></h2><p>统一主键生成器，主键路由如下，比如前三位，前四位作为路由，大公司用五六位作为业务路由</p><table tabindex="0"><thead><tr><th>产品（product）</th><th>领域（domain）</th></tr></thead><tbody><tr><td>1</td><td>01</td></tr><tr><td>2</td><td>02</td></tr><tr><td>10</td><td>01</td></tr><tr><td>100</td><td>01</td></tr><tr><td>1000</td><td>01</td></tr></tbody></table><p>中间部分用生成器，比如用号段生成器，008</p><p>租户登录的时候，租户名，hash，拿后三位或者后四位作为分片键</p><p>比如是1234</p><p>租户ID的后四位就用1234</p><p>完整的租户ID，可能就是101 008 1234</p><p>其他的领域模型，比如跟租户关联的就可以跟租户的分片键相同。</p><p>比如订单</p><p>这样分库分表的时候就能分到同一个库中</p><p>查询的话用ES实现</p><h2 id="前端-客户端的动态绑定" tabindex="-1">前端，客户端的动态绑定 <a class="header-anchor" href="#前端-客户端的动态绑定" aria-label="Permalink to &quot;前端，客户端的动态绑定&quot;">​</a></h2><p>以前我们做开发的时候，页面都是写死的，然后前后端联调</p><p>现在前端都是服务器端根据元数据配置返回的</p><p>比如登录页面：不同租户的登录页面就不一样</p><p>前端拿到API返回的结果后，再动态生成页面</p><h2 id="服务器端的动态增强" tabindex="-1">服务器端的动态增强 <a class="header-anchor" href="#服务器端的动态增强" aria-label="Permalink to &quot;服务器端的动态增强&quot;">​</a></h2><ul><li>可以通过远程加载字节码来实现动态增强 class.forName(&quot;远程字节码文件&quot;)</li><li>可以使用规则引擎，远程加载一个规则文件，比如使用drools</li></ul><h2 id="打包部属" tabindex="-1">打包部属 <a class="header-anchor" href="#打包部属" aria-label="Permalink to &quot;打包部属&quot;">​</a></h2><ul><li><p>客户端打包跟租户绑定，不同租户打不同包，这个好解决。</p></li><li><p>web端打包部属</p><ul><li><p>用户侧前端用域名和文根来实现</p><p>比如：</p><ul><li><p>一级租户用域名</p><p>hw.data.com</p><p>jd.data.com</p></li><li><p>二级租户用文根</p><p>jd.data.com/pay</p></li></ul></li><li><p>租户管理侧前端</p><p>tenant.data.com 登录页面 租户名 用户名 用户密码</p></li><li><p>超级管理员侧</p><p>admin.data.</p></li></ul></li></ul>',47)])])}const u=p(l,[["render",r]]);export{m as __pageData,u as default};
